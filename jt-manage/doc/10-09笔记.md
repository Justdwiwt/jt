# Redis

> 缓存可以提升系统运行过程中数据获取的效率，是在工程内部使用的（java代码）。

企业中使用多种多样的第三方缓存技术，引入到工程中使用。

## Redis定义

> nosql，key-value，可持久化，分布式，内存，缓存，非关系型数据库

* 结构化数据：一类相同特点的数据集合
* 非结构化数据：海量数据，大数据
* 关系型数据库：结构化数据（表格/schema）
    * Oracle
    * mysql
    * mssqlserver
* 非关系型数据库：可以存储结构化数据，也可以存储非结构化数据
    * MongoDB
    * Redis

非关系型数据库存储非结构化数据的格式：key-value

**使用内存存储数据的缺点：** 

* 量少（分布式，海量集群解决）
* 容易丢失

**如果缓存中的数据由于内存断电丢失，会造成缓存的击穿——雪崩**

一旦出现雪崩，整个系统将会进入瘫痪状态。

Redis支持内存数据进行写入磁盘的操作（宕机数据恢复，容灾）。

## 雪崩/缓存击穿

> memoryCache：Redis之前占领市场的分布式缓存技术，性能非常高，但是不支持内存数据的持久化，易出现由于系统故障导致的缓存雪崩。

### 海量请求访问

如果数据的访问，由于缓存的未命中（缓存中没数据，内存数据丢失等原因），海量访问涌入数据库，数据瓶颈导致集群宕机。
重启数据库，缓存依然未命中，海量请求并未消失，造成数据库宕机、重启、系统不可用。

memoryCache与Redis对比：

* 性能相近
* Redis支持可持久化，memoryCache不支持
* 缓存的数据结构
    * memoryCache只支持String
    * Redis支持String、hash集合（list set zset）

## Redis缓存

> Redis最重要的功能，使用缓存的功能解决系统性能问题。

### 数据库缓存

利用key-value结构记录缓存内容，同一个sql语句是一个key值。
**下次执行相同的语句（查询）时，不会再封装`resultSet`**，减少了数据从磁盘的IO。

### 持久层缓存

减少了连接数据库的次数，并且减少`resultSet`封装成对象的过程。

### 控制层和业务层缓存

减少数据传递次数

* Redis作为缓存在SSM框架中的使用是在业务层中引入Redis代码实现数据的读写。

## Redis的安装和启动

1. 获取安装包
2. 解压

    ```bash
    tar -xf redis.tar.gz
    ```

3. 编译安装
    
    ```bash
    make && make install
    ```

4. 默认启动Redis

    ```bash
    redis-server
    ```
    
5. 后台启动Redis

    ```bash
    redis-server &
    ```

6. 检查后台运行的Redis服务

    ```bash
    ps -ef|grep redis
    ```
    
## Redis基础命令
 
Redis作为缓存可以在内存中存储五种数据类型：
 
* String：字符串类型
* hash：面向对象的存储方式
* list：链表
* set：集合
* zset：有序集合
 
### String
 
```bash
keys *
```

> 查看当前Redis中存在的所有key-value数据。

```bash
set key value
```

> 存放一个String类型的value数据，利用key值保存。

```bash
get key
```

> 获取String类型的数据。

```bash
select[]
#0-15
```

> 默认Redis将会进行分库操作，每个库和其他的数据库不连通。默认0号库。

```bash
exists key
```

> 判断key值是否存在。

* `get`能完成`exists`的功能，但`get`做了数据的读取操作
* Redis的value存储最大值为512M（version 3.2.11）

```bash
del key
```

> 删除key对应的value数据对。

```bash
type key
```

> 查看数据类型

```bash
save dump
```

> 将当期Redis的数据写出到默认Redis根目录的dump文件。

```bash
flushall
```

> 将内存和持久化文件的所有数据清空。

```bash
flushdb
```

> 清空当期库的内存数据。

```bash
incr decr key
```

> 自增自减，key对应的value是String，必须是数字。

```bash
incrby decrby key
```

> 对key的增加和减少设定步数。

```bash
append key value
```

> 数据追加。

```bash
expire key seconde
```

> 设定当前key的超时时间。

* Redis有自动删除数据的逻辑——最近最久未使用

```bash
ttl key
```

> 查看key的超时时间。

### Hash

```bash
hset key field value
```

> 设置一个hash结构的一条数据。

```bash
hget key field
```

> 获取一个hash结构数据的某个属性值。

```bash
hexists
```

> 判断hash结构的key是否存在。

```bash
hvals hkeys key
```

> 只获取属性值。

```bash
hincrby
```

> hash结构的计步器。

```bash
hlen key
```

> 获取hash数据结构的所有属性个数。

### 集合数据类型

> 在list中，左为上，右为下。从上到下相当于从左到右。

```bash
lpush key value
```

> 从左侧将value数据添加到一个名为key的list中。

```bash
lrange key [] []
# 起始位置 结束位置
```

> 展示链表的内容，从起止位置到结束位置。

```bash
rpush key value
```

> 从右侧插入链表数据，不是链表的结构有l必有r。

```bash
linsert []
```

> 插入数据。

* before：从左侧插入
* after：从右侧插入
* pivot：参数 原有的元素值
* value：准备新增的数据

```bash
lset
```

> 设置list中指定下标的元素值。

```bash
lrem
```

> 从list中删除count的相同值的元素。

* count > 0：表示删除的值从上往下删除
* count < 0：表示从下往上删除
* count = 0：全部删除

```bash
lpop
```

> 从list的头部删除元素，并且当前客户端获取删除的元素。

```bash
rpop
```

> 从尾部删除，返回元素数据。

```bash
rpoplpush
```

> 从第一个list的尾部移除元素，添加到第二个list的头部。

```bash
llen
```

> 返回list的元素个数。

## jedis

* 依赖jar包

    ```xml
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-redis</artifactId>
            <version>1.4.5.RELEASE</version>
        </dependency>
    </dependencies>
    ```

1. jedis链接Redis

    ```java
    public class JedisTest {
        @Test
        public void test01() {
            //从代码链接任何技术，必须的参数
            //ip port，新建一个jedis对象，获取ip和端口信息
            //即可完成链接服务的操作
            Jedis jedis=new Jedis("106.75.120.140", 6380);
            //利用着一个链接对象，操作redis服务
            //jedis.set("name", "hanlaoshi");
            System.out.println(jedis.get("city"));
            jedis.close();
        }
    }
    ```

2. 模拟商品的缓存逻辑

    ```java
    public class JedisTest {
        @Test
        public void test02() {
            String id="123";
            String product="荣耀9i 4GB+64GB 魅海蓝 移动联通电信4G全面屏手机 双卡双待";
            System.out.println("用户开始访问商品，商品id"+id);
            //根据商品访问的业务逻辑，生成全局唯一的key对应商品的访问
            String key="ITEM_"+id;//item_123
            //链接redis
            Jedis jedis=new Jedis("106.75.120.140", 6380);
            //利用jedis客户端判断key是否存在
            if(jedis.exists(key)) {//表示存在缓存数据
                String info=jedis.get(key);
                System.out.println("数据从缓存获取，商品信息是："+info);
                jedis.close();
            }else {//缓存不存在数据，从数据库获取
                System.out.println("select * from product where id="+id);
                System.out.println("从数据库获取数据，并且存储到缓存，荣耀9i 4GB+64GB 魅海蓝 移动联通电信4G全面屏手机 双卡双待");
                jedis.set(key, product);
            }
        }
    }
    ```

3. 自定义数据存储的分片计算逻辑

    ```java
    public class JedisTest {
        @Test
        public void test03() {
            //准备jedis链接6379，6380，6381的客户端
            Jedis jedis1=new Jedis("106.75.120.140", 6379);
            Jedis jedis2=new Jedis("106.75.120.140", 6380);
            Jedis jedis3=new Jedis("106.75.120.140", 6381);
            //海量数据的存储需求
            for(int i=0;i<1000;i++) {
                //每次循环，相当于需要存储一个商品信息，生成对应的key-value
                String key="key_"+i;
                String value="value_"+i;
                
                if(i<33) {
                    jedis1.set(key, value);//33 以下的数据存储到6379
                }else if(i<66) {
                    jedis2.set(key, value);//6380
                }else {
                    jedis3.set(key, value);
                }
                
            }
            //海量数据的获取需求
            for(int i=0;i<100;i++) {
                String key="key_"+i;
                if(i<33) {
                    System.out.println(jedis1.get(key));//33 以下的数据存储到6379
                }else if(i<66) {
                    System.out.println(jedis2.get(key));
                }else {
                    System.out.println(jedis3.get(key));
                }
            }
        }
    }
    ```

    * 随着数据的不断增长和数据内容的不可控：
        * 数据倾斜严重（修改自定义的计算逻辑）
        * key值的取值范围发生变动

4. hash取余

    ```java
    public class JedisTest {
        @Test
        public void test04() {
            //准备jedis链接6379，6380，6381的客户端
            Jedis jedis1=new Jedis("106.75.120.140", 6379);
            Jedis jedis2=new Jedis("106.75.120.140", 6380);
            Jedis jedis3=new Jedis("106.75.120.140", 6381);
            for(int i=0;i<1000;i++) {
                String key="aklsdhflasjfls"+i;
                String value="value"+i;
                
                //获取取余结果
                int result=(key.hashCode()&Integer.MAX_VALUE)%3;
                if(result==0) {//存储到6379
                    jedis1.set(key, value);	
                }
                if(result==1) {//6380
                    jedis2.set(key, value);
                }
                if(result==2) {//6381
                    jedis3.set(key, value);
                }
            }
        }
    }
    ```

5. hash一致性

    ```java
    public class JedisTest {
        @Test
        public void test05() {
            //不能使用单独的链接对象jedis来操作集群，需要创建分片的对象
            //收集节点信息，告诉jedis集群的所有节点都是谁
            List<JedisShardInfo> infoList=new ArrayList<JedisShardInfo>();
            
            //封装3个节点的链接信息
            JedisShardInfo info1=new 
                    JedisShardInfo("106.75.120.140", 6379);
            JedisShardInfo info2=new 
                    JedisShardInfo("106.75.120.140", 6380);
            JedisShardInfo info3=new 
                    JedisShardInfo("106.75.120.140", 6381);
            infoList.add(info1);
            infoList.add(info2);
            infoList.add(info3);
            
            //利用收集到的信息，创建一个分片对象，分片对象的操作和jedis对象一值
            //但是在存储，读取数据时，已经对key值做了数据分片的计算，从而可以正确的到
            //某个节点获取，存储数据
            ShardedJedis sJedis=new ShardedJedis(infoList);
            //sJedis.set("name", "haha");
            
            for(int i=0;i<1000;i++) {
                String key=i+"";
                String value=i+"";
                sJedis.set(key, value);
            }
        }
    }
    ```
    
6. 分片的连接池

    ```java
    public class JedisTest {
        @Test
        public void test06() {
            //链接池中的每个链接对象，都需要链接3个节点的集群
            //收集节点信息，告诉jedis集群的所有节点都是谁
            List<JedisShardInfo> infoList=new ArrayList<JedisShardInfo>();
            
            //封装3个节点的链接信息
            JedisShardInfo info1=new 
                    JedisShardInfo("106.75.120.140", 6379);
            JedisShardInfo info2=new 
                    JedisShardInfo("106.75.120.140", 6380);
            JedisShardInfo info3=new 
                    JedisShardInfo("106.75.120.140", 6381);
            infoList.add(info1);
            infoList.add(info2);
            infoList.add(info3);
            //连接池，具有自己的一些配置信息，最大连接数，最大空闲链接
            //准备一个配置对象
            JedisPoolConfig config=new JedisPoolConfig();
            //设置一些参数
            config.setMaxIdle(8);
            config.setMaxTotal(200);//最大连接数
            //创建分片连接池对象
            ShardedJedisPool pool=new 
                    ShardedJedisPool(config, infoList);
            //获取链接对象
            ShardedJedis sJedis = pool.getResource();
            pool.returnResource(sJedis);
        }
    }
    ```
    
## 框架整合jedis

### 单节点引入框架代码

> 需求：通过框架，利用id查询user信息

1. 发起请求，传递id
2. controller调用service（缓存逻辑），调用mybatis持久层框架，执行sql

请求url：

```yaml
localhost: 8090/user?id=1/2
```

利用jedis的链接对象完成缓存逻辑：

* 性能上，非常差
* 代码内存占用大，高并发的访问，jedis创建的数量太多，没有对链接对象的管理
* 单个Redis节点存储数据小
* 应该表写`close`方法，防止内存溢出
    * 即使使用`close`方法，链接资源频繁的创建和销毁
    
**使用spring框架来管理一个连接池对象，在使用缓存的位置，注入使用。**

### 框架整合连接池

1. 配置链接信息
    
    ```yaml
    spring:
     redis:
      pool:
       maxIdle: 8
       maxTotal: 200
       minIdle: 1
       maxWait: 5000
    ```

2. 利用属性的注入`@Configuration @Value`初始化一个连接池对象

    编写一个配置类，利用`@Value`读取配置文件属性
    利用`@Bean`作用在一个初始化方法中，完成jedis分片连接池的创建工作

    ```java
    package com.jt.config;
    
    import java.util.ArrayList;
    import java.util.List;
    
    import org.springframework.beans.factory.annotation.Value;
    import org.springframework.context.annotation.Bean;
    import org.springframework.context.annotation.Configuration;
    
    import redis.clients.jedis.JedisPoolConfig;
    import redis.clients.jedis.JedisShardInfo;
    import redis.clients.jedis.ShardedJedisPool;
    
    @Configuration
    public class RedisConfig {
        
        //5个私有属性，利用属性注入，赋值
        @Value("${spring.redis.nodes}")
        private String nodes;
        @Value("${spring.redis.pool.maxIdle}")
        private Integer maxIdle;
        @Value("${spring.redis.pool.minIdle}")
        private Integer minIdle;
        @Value("${spring.redis.pool.maxTotal}")
        private Integer maxTotal;
        @Value("${spring.redis.pool.maxWait}")
        private Integer maxWait;
        
        //创建一个连接池对象，初始化的方法，返回连接池对象
        @Bean
        public ShardedJedisPool getPool(){
            //收集节点信息
            //{"10.9.9.9:6379","10.9.9.9:6380"}
            //收集的list对象
            List<JedisShardInfo> infoList = new ArrayList<>();
            String[] hostAndPorts = nodes.split(",");
            for (String node : hostAndPorts) {
                String host=node.split(":")[0];
                int port=Integer.parseInt(node.split(":")[1]);
                JedisShardInfo info=new JedisShardInfo(host, port);
                infoList.add(info);
            }
            
            // 创建config对象
            JedisPoolConfig config=new JedisPoolConfig();
            config.setMaxIdle(maxIdle);
            config.setMaxWaitMillis(maxWait);
            config.setMaxTotal(maxTotal);
            config.setMinIdle(minIdle);
            //  构造连接池对象
            return ShardedJedisPool(config, infoList);
        }
    }
    ```
